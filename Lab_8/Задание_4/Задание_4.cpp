#include <iostream>
#include<stdlib.h>
#include<time.h>
#include <cmath>
#include <Windows.h>

using namespace std;

int main()
{
	SetConsoleOutputCP(1251);
	SetConsoleCP(1251);

	int N = 10;
	// 1
	int* A = new int[N]; // new - оператор который выдает область ОП
	// Проверка на свободное место в ОП
	if (A == NULL)
	{
		cout << "NO Memory\n";
		system("pause");
		return 0;
	}

	for (int i = 0; i < N; i++)
	{
	
		if (i == 0)
		{
			A[i] = 1;
		}
		else
		{
			int fakt = 1;
			for (int j = 1; j <= i; j++)
			{
				fakt *= j;
			}
			A[i] = fakt;
		}
		cout << "A[" << i << "]: " << A[i] << endl;
	
	}


	//////////////////////////////////////
	// Нахождение минимального значения массива
	int min = A[0], Index_min = 0; // Загвостка с min если написать просто min = 0, будет проблема с условием
	for (int i = 1; i < N; i++)
	{
		if (min > A[i])
		{
			min = A[i]; // Оно по сути и не нужно, я в конце работаю только с индексом
			Index_min = i;
		}
	}
	cout << "min: " << min << endl;
	//////////////////////////////////////


	//////////////////////////////////////
	// Cумму элементов массива, расположенных между первым и последним положительными элементами
	int sum = 0, index_poslednee_polozit = 0;

	// Последнее положительное число
	for (int i = N-1; i >= 0; i--)
	{
		if (A[i] > 0)
		{
			index_poslednee_polozit = i;
			break;
		}
	}
	// Начало от первого до pervoe_polozit
	for (int i = 0; i < index_poslednee_polozit; i++)
	{
		if (A[i] > 0)
		{
			i += 1; // Чтобы первое положительное число не входило в диапазон
			for (;i < index_poslednee_polozit;i++)
			{
				sum += A[i];
			}
		}
	}
	cout << "Cумму элементов массива, расположенных между первым и последним положительными элементами: " << sum << endl;
	//////////////////////////////////////


	//////////////////////////////////////
	cout << "Переобразованный массив" << endl;
	// преобразовать массив таким образом, чтобы сначала располагались все элементы, равные нулю, а потом - все остальные.
	int index_null = 0; // Для индекса первого элемента
	for (int i = 0; i < N; i++)
	{
		if (A[i] == 0)
		{
			int t = A[i]; // Промежуточная переменная
			A[i] = A[index_null];
			A[index_null] = t; 
			index_null++;
		}
		
	}
	// Распечатаю массив для проверки
	for (int i = 0; i < N; i++)
	{
		cout << "A[" << i << "]: " << *(A + i) << endl; // Решил вывести с помощью Арифметики указателей \ или косвенная адресация
	}
	//////////////////////////////////////


	// ОБЯЗАТЕЛЬНО, если не сделать будет утечка памяти 
	// Очистим оперативку 
	delete[] A; // Удаляю массив из ДООП
	A = NULL; // зануляю указатель, чтобы он указывал на пустоту

	system("pause");
	return 0;
}
